---
title: "Smart-seq3 analysis"
output: html_document
---

This vignette replicates our results for the Smart-seq2 with UMIs and
Smart-seq3 data. 

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(spASE)
library(biomaRt)
library(RCurl)
library(latex2exp)
library(RColorBrewer)
set.seed(1337)

expit <- function(x) {
  return(exp(x)/(1+exp(x)))
}
```

## Smart-seq2 with UMIs data

First download the data - Smart-seq2 w/ UMI data. The method requires input
in the form of two matrices where  the  row names are the unique genes and the
columns are the unique cells.

```{r}
# Load Smart-seq2 with UMIs data
c57.ss2 <- as.matrix(read.csv(text=getURL('https://raw.githubusercontent.com/sandberg-lab/txburst/master/data/SS3_c57_UMIs_concat.csv'), row.names = 1))
cast.ss2 <- as.matrix(read.csv(text=getURL('https://raw.githubusercontent.com/sandberg-lab/txburst/master/data/SS3_cast_UMIs_concat.csv'), row.names = 1))
```

Remove X-chromosome genes, since they are not expected to follow the same
assumptions about ASE as autosomal genes.

```{r}
# load list of X-chromosome genes
xchr <- read.delim('../inst/extdata/MGImarkerQuery_20190611_114216.txt')$Symbol
xchr.idx <- which(rownames(c57.ss2) %in% xchr)
c57.ss2 <- c57.ss2[-xchr.idx,]
cast.ss2 <- cast.ss2[-xchr.idx,]
```

Now we can fit the beta-binomial model for genes expressed in at least half
of all cells (change number of cores used if necessary) using the  `scase`
function.

```{r}
ss2 <- scase(matrix1=c57.ss2, matrix2=cast.ss2, min.cells = ncol(c57.ss2)/2, cores=2)
```

We can view the results data frame and arrange it by  e.g. descending q-value:

```{r}
head(ss2 %>% arrange(qval), n=10)
```

##  Smart-seq3 data

Next, download the Smart-seq3 data. The rows (as of the last editing date of
this vignette) are in terms of ENSEMBL gene  IDs, not MGI symbols, so first I
convert them  to MGI symbols  so that they  can be matched with the Smart-seq2
data. I remove  the  ones that do not have a one-to-one matching.

```{r}
c57.ss3 <- as.matrix(read.csv(text=getURL('https://raw.githubusercontent.com/sandberg-lab/aRME_and_bursting/main/data/F1_ref/umiSplit_c57.qc.csv'), row.names = 1))
cast.ss3 <- as.matrix(read.csv(text=getURL('https://raw.githubusercontent.com/sandberg-lab/aRME_and_bursting/main/data/F1_ref/umiSplit_cast.qc.csv'), row.names = 1))
# to get common names rather than ensembl id's i used this:
mouse <- useMart('ensembl', dataset='mmusculus_gene_ensembl')
res <- getBM(attributes = c('ensembl_gene_id', 'mgi_symbol'), mart=mouse)
mgi_symbols <- left_join(data.frame(ensembl_gene_id=rownames(c57.ss3)),
                         res, by = 'ensembl_gene_id') 
# some of them are duplicated after converting to ensembl gene id, 
# some of them don't have an mgi_symbol, and some of them have two mgi_symbols,
# i will just remove them  all
mgi_symbols <- mgi_symbols[-which(duplicated(mgi_symbols$ensembl_gene_id)),]
remove.idx <- which(duplicated(mgi_symbols$mgi_symbol))
c57.ss3 <- c57.ss3[-remove.idx,]; cast.ss3 <- cast.ss3[-remove.idx,]; 
mgi_symbols <- mgi_symbols[-remove.idx,]
rownames(c57.ss3) <- mgi_symbols$mgi_symbol 
rownames(cast.ss3) <- mgi_symbols$mgi_symbol
```

Then we take out X-chromosome genes for this one as well and fit the
beta-binomial model.

```{r}
xchr.idx <- which(rownames(c57.ss3) %in% xchr)
c57.ss3 <- c57.ss3[-xchr.idx,]
cast.ss3 <- cast.ss3[-xchr.idx,]
ss3 <- scase(c57.ss3, cast.ss3, min.cells=ncol(c57.ss3)/2, cores=2)
```

There is a built-in plotting function that takes in the results data frame
and produces plots for the desired genes. (They can  be saved instead of  plotted
by setting the `save` parameter  to be the prefix of the filename for the output).

```{r}
plotScase(c57.ss3, cast.ss3, ss3, genes=c('Ercc1', 'Phgdh', 'Rnf5', 'Ywhae'))
```

## Comparing estimates using SS2 with UMIs and SS3 

The following calculates the average coverage per cell per gene per data set:

```{r}
# average coverage per cell per data set
c57.ss3[which(is.na(cast.ss3))] <- NA # NAs are placed where that gene didn't have any allele-specific UMI counts in that cell. ensure we are only using gene/cell combos which had both alleles
cast.ss3[which(is.na(c57.ss3))] <- NA
c57.ss2[which(is.na(cast.ss2))] <- NA 
cast.ss2[which(is.na(c57.ss2))] <- NA
print(paste('Average coverage/cell for SS3:', mean(colMeans(c57.ss3+cast.ss3,na.rm=T))))
print(paste('Average coverage/cell for SS2 w/ UMIs:', mean(colMeans(c57.ss2+cast.ss2,na.rm=T))))
```

Plotting all the  point estimates from  the beta-binomial fit allows us to
visualize the variability between  data sets:

```{r}
# Figure 2e variability between data sets
both <- left_join(ss2, ss3, by = 'gene', suffix=c('.2','.3')) %>%
  filter((flag.2==''), (flag.3=='')) %>%
  filter(!is.na(logit.p.3))
# ss2 w/ umi vs. ss3 estimates of p maternal
both %>%
  ggplot(aes(x = p.2, y = p.3)) +
  geom_point(alpha=0.25, size=0.5) +
  geom_abline(slope=1, intercept=0, color='red', lty='dashed') +
  theme_classic() +
  xlab(TeX(r'($\hat{p}$, Smart-seq2 with UMIs)')) +
  ylab(TeX(r'($\hat{p}$, Smart-seq3)'))
ggsave(filename='figure2e.png', width=3,height=2.5)
```
Calculate  the $r^2$  between the point estimates:

```{r}
cor(both$p.2, both$p.3, method='pearson')
```

We can categorize each gene by whether or not it was signiifcant ($q \leq 0.01$) 
in either one, both, or no data set, and whether or not  the direction of the 
estimate agreed.

```{r}
# Figure 2f agreement between the two data sets
both <- both %>%
  mutate(label = case_when(
   (qval.2 <= 0.01) & (qval.3 <= 0.01) & (sign(p.2-0.5)==sign(p.3-0.5)) ~  'agree signif',
   (qval.2 <= 0.01) & (qval.3 <= 0.01) & (sign(p.2-0.5)!=sign(p.3-0.5)) ~  'disagree signif',
   (qval.2 <= 0.01) & (qval.3 > 0.01)  ~  'only ss2',
   (qval.2 > 0.01) & (qval.3 <= 0.01)  ~  'only ss3',
   (qval.2 > 0.01) & (qval.3> 0.01)  ~ 'neither signif',
    TRUE ~ '?'
  ))
both.label <- both %>% 
  group_by(label) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  mutate(label = factor(label, levels=unique(label))) %>%
  mutate(fill.color = factor(label, levels=unique(label), labels=brewer.pal(5, 'Dark2')))
both.label %>%
  ggplot(aes(x = label, y = count)) +
  geom_bar(aes(fill=fill.color), stat='identity') +
  scale_fill_identity() +
  theme_classic() +
  ylab('num genes') +
  xlab('category') +
  theme(axis.text.x = element_text(angle=45, hjust=1))
ggsave(filename='figure2f.png', height=3, width=2)
both %>%
  left_join(both.label, by = 'label') %>%
  ggplot(aes(x = expit(logit.p.2), y = expit(logit.p.3))) +
  geom_point(aes(color = fill.color), alpha=0.25, size=0.5) +
  scale_color_identity() +
  geom_abline(slope=1, intercept=0, color='red', lty='dashed') +
  theme_classic() +
  xlab(TeX(r'($\hat{p}$, Smart-seq2 with UMIs)')) +
  ylab(TeX(r'($\hat{p}$, Smart-seq3)')) +
  theme(legend.position='none')
ggsave(filename='figure2e.png', width=3,height=2.5)
```

## Calculating variance within and across data  sets

Next, we assess whether or not the variance is underestimated by looking at the
variance  of  the distribution of the difference in MLE and seeing if it's 
distributed $\mathcal{N}(0,1)$. (Supplemental Figure S3)

Within SS2 with UMIs:

```{r}
# compare within-data set to across-data set variance
# within ss2:
half1 <- sample(1:ncol(c57.ss2), size=ncol(c57.ss2)/2, replace=F)
ss2.half1 <- scase(c57.ss2[,half1], cast.ss2[,half1], min.cells=length(half1)/2)
ss2.half2 <- scase(c57.ss2[,-half1], cast.ss2[,-half1], min.cells=length(half1)/2)
```

```{r}
both.half.2 <- left_join(ss2.half1, ss2.half2, by='gene', suffix=c('.1','.2')) %>%
  filter(flag.1=='', flag.2=='', !is.na(logit.p.2)) %>%
  mutate(p.diff = (logit.p.1-logit.p.2)/sqrt(logit.p.sd.1^2+logit.p.sd.2^2))
png(filename='suppfig2a.png', width=5, height=5, units='in', res=100)
qqnorm(both.half.2$p.diff, main=TeX(r'($(\hat{p}_1-\hat{p}_2)/\sqrt{Var(\hat{p}_1) + Var(\hat{p}_2)}$ within Smart-seq2)'))
abline(0,1,col='red')
dev.off()
```

Within SS3:

```{r}
# compare within-data set to across-data set variance
# within ss3:
half1 <- sample(1:ncol(c57.ss3), size=ncol(c57.ss3)/2, replace=F)
ss3.half1 <- scase(c57.ss3[,half1], cast.ss3[,half1], min.cells=length(half1)/2)
ss3.half2 <- scase(c57.ss3[,-half1], cast.ss3[,-half1], min.cells=length(half1)/2)
```

```{r}
both.half.3 <- left_join(ss3.half1, ss3.half2, by='gene', suffix=c('.1','.2')) %>%
  filter(flag.1=='', flag.2=='', !is.na(logit.p.2)) %>%
  mutate(p.diff = (logit.p.1-logit.p.2)/sqrt(logit.p.sd.1^2+logit.p.sd.2^2))
png(filename='suppfig2b.png', width=5, height=5, units='in', res=100)
qqnorm(both.half.3$p.diff, main=TeX(r'($(\hat{p}_1-\hat{p}_2)/\sqrt{Var(\hat{p}_1) + Var(\hat{p}_2)}$ within Smart-seq3)'))
abline(0,1,col='red')
dev.off()
```

Across SS2 with UMIs and SS3:

```{r}
# across dataset variance
both <- both %>% mutate(p.diff = (logit.p.2-logit.p.3)/sqrt(logit.p.sd.2^2+logit.p.sd.3^2))
png(filename='suppfig2c.png', width=5, height=5, units='in', res=100)
qqnorm(both$p.diff, main=TeX(r'($(\hat{p}_1-\hat{p}_2)/\sqrt{Var(\hat{p}_1) + Var(\hat{p}_2)}$ across datasets)'))
abline(0,1,col='red')
dev.off()
```

Now estimate the batch effect variance and fit  the model again whileadjusting
for the the extra variance observed using the `add.var` option:

```{r}
# estimate batch effect variance 
batch.var <- .5*(mean((both$logit.p.2-both$logit.p.3)^2) - (mean(both$logit.p.sd.2^2)+mean(both$logit.p.sd.3^2)))
# run again adjusting confidence intervals
ss2 <- scase(c57.ss2, cast.ss2, min.cells=ncol(c57.ss2)/2, cores=2, add.var=batch.var)
ss3 <- scase(c57.ss3, cast.ss3, min.cells=ncol(c57.ss3)/2, cores=2, add.var=batch.var)
both <- left_join(ss2, ss3, by = 'gene', suffix=c('.2','.3')) %>%
  filter((flag.2==''), (flag.3=='')) %>%
  filter(!is.na(logit.p.3))
```

Visualize the improvement in the QQ plot:

```{r}
# across dataset variance with adjusted s.e's
both <- both %>% mutate(p.diff.adj = (logit.p.2-logit.p.3)/sqrt(logit.p.sd.adj.2^2+logit.p.sd.adj.3^2))
png(filename='suppfig2d.png', width=5, height=5, units='in', res=100)
qqnorm(both$p.diff.adj, main=TeX(r'($(\hat{p}_1-\hat{p}_2)/\sqrt{Var(\hat{p}_1) + Var(\hat{p}_2)}$ across, corrected)'))
abline(0,1,col='red')
dev.off()
```

Create the bar chart of categories again using the adjusted standard errors.

```{r}
#bar chart of categories again
both <- both %>%
  mutate(label.adj = case_when(
   (qval.adj.2 <= 0.01) & (qval.adj.3 <= 0.01) & (sign(p.2-0.5)==sign(p.3-0.5)) ~  'agree signif',
   (qval.adj.2 <= 0.01) & (qval.adj.3 <= 0.01) & (sign(p.2-0.5)!=sign(p.3-0.5)) ~  'disagree signif',
   (qval.adj.2 <= 0.01) & (qval.adj.3 > 0.01)  ~  'only ss2',
   (qval.adj.2 > 0.01) & (qval.adj.3 <= 0.01)  ~  'only ss3',
   (qval.adj.2 > 0.01) & (qval.adj.3> 0.01)  ~ 'neither signif',
    TRUE ~ '?'
  ))
both.label.adj <- both %>% 
  group_by(label.adj) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  mutate(label.adj = factor(label.adj, levels=unique(label.adj))) %>%
  left_join(both.label %>% dplyr::select(label,fill.color), by=c('label.adj'='label'))
both.label.adj %>%
  ggplot(aes(x = label.adj, y = count)) +
  geom_bar(aes(fill=fill.color), stat='identity') +
  scale_fill_identity() +
  theme_classic() +
  ylab('num genes') +
  xlab('category') +
  theme(axis.text.x = element_text(angle=45, hjust=1))
ggsave(filename='figure2g.png', height=3, width=2)
```

